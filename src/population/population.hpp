#pragma once

#include <vector>
#include <functional>
#include <ctime>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <random>
#include <cctype>
#include <random>

using u32 = uint_least32_t; 

// Class Outline ----------------------------------------------------------------------------------------------------------------------------

// Class for a population of genes of type T, with fitness values of type L
template<typename T, typename L>
class Population{

protected:

    std::vector<T> genes;
    std::mt19937 generator;

    // Function taking a gene of type T and returning its fitness value of type L
    const std::function<std::vector<L>(const T&)>& evaluate;
    // Function taking a vector of genes of type T and returning a vector of parents of type T
    const std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& selectParents;
    // Function taking a vector of genes of type T and returning a vector of mutated genes of type T
    const std::function<std::vector<T>(const T&, std::mt19937&)>& mutate;
    // Function taking a vector of genes of type T and returning a vector of recombined genes of type T
    const std::function<std::vector<T>(const T&, const T&, std::mt19937&)>& recombine;
    // Function taking two vectors of genes of type T (parents and children) and returning a selected vector of genes of type T
    const std::function<const std::vector<T>&(const std::vector<T>&, const std::vector<T>&)>& selectSurvivors;
    // Function taking a vector of fitness values of type L and returning a vector of ranks of type int
    const std::function<std::vector<int>(const std::vector<L>&)>& rank;

public:

    Population();

    // Constructor for population initialized with passed genes initial_genes
    Population(
        u32 seed,
        const std::vector<T>& initial_genes,
        const std::function<std::vector<L>(const std::vector<T>&)>& evaluate,
        const std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& selectParents,
        const std::function<std::vector<T>(const std::vector<T>&, std::mt19937& generator)>& mutate,
        const std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& recombine,
        const std::function<std::vector<T>(const std::vector<T>&, const std::vector<T>&)>& selectSurvivors,
        const std::function<std::vector<int>(const std::vector<L>&)>& rank
    );

    // Constructor for population of size size will with genes generated by function initialize
    Population(
        u32 seed,
        const std::function<std::vector<T>(std::mt19937&)>& initialize,
        const std::function<std::vector<L>(const std::vector<T>&)>& evaluate,
        const std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& selectParents,
        const std::function<std::vector<T>(const std::vector<T>&, std::mt19937& generator)>& mutate,
        const std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& recombine,
        const std::function<std::vector<T>(const std::vector<T>&, const std::vector<T>&)>& selectSurvivors,
        const std::function<std::vector<int>(const std::vector<L>&)>& rank
    );

    void execute(); //executes one iteration of the evolutionary algorithm
    void execute_multiple(int generations); //executes 'generations' iterations of the evolutionary algorithm
    std::vector<T> get_bests(); //returns the best genes in the population
    std::vector<T> get_genes(); //returns the current genes in the population
    std::string to_string(); //returns a string representation of the population
};

// Class Implementation ---------------------------------------------------------------------------------------------------------------------

template<typename T, typename L>
Population<T, L>::Population(){};

template<typename T, typename L>
Population<T, L>::Population(
    u32 seed,
    const std::vector<T>& initial_genes,
    const std::function<std::vector<L>(const std::vector<T>&)>& evaluate,
    const std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& selectParents,
    const std::function<std::vector<T>(const std::vector<T>&, std::mt19937& generator)>& mutate = nullptr,
    const std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& recombine = nullptr,
    const std::function<std::vector<T>(const std::vector<T>&, const std::vector<T>&)>& selectSurvivors = nullptr,
    const std::function<std::vector<int>(const std::vector<L>&)>& rank = nullptr
) : generator(seed), size(initial_genes.size()), genes(initial_genes), evaluate(evaluate), selectParent(selectParent), mutate(mutate), recombine(recombine), selectSurvivors(selectSurvivors), rank(rank) {}

template<typename T, typename L>
Population<T, L>::Population(
    u32 seed,
    const std::function<std::vector<T>(std::mt19937&)>& initialize,
    const std::function<std::vector<L>(const std::vector<T>&)>& evaluate,
    const std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& selectParents,
    const std::function<std::vector<T>(const std::vector<T>&, std::mt19937& generator)>& mutate = nullptr,
    const std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& recombine = nullptr,
    const std::function<std::vector<T>(const std::vector<T>&, const std::vector<T>&)>& selectSurvivors = nullptr,
    const std::function<std::vector<int>(const std::vector<L>&)>& rank = nullptr
) : generator(seed), genes(size), evaluate(evaluate), selectParent(selectParent), mutate(mutate), recombine(recombine), selectSurvivors(selectSurvivors), rank(rank) {
    genes = initialize(generator);
}

template<typename T, typename L>
void Population<T, L>::execute() {
    std::vector<T> parents = selectParents(genes, generator);
    std::vector<T> children = (recombine == nullptr) ? parents : recombine(parents[0], generator);
    children = (mutate == nullptr) ? children : mutate(children, generator);
    genes = (selectSurvivors == nullptr) ? children : selectSurvivors(genes, children);
}

template<typename T, typename L>
void Population<T, L>::execute_multiple(int generations){
    for(int i = 0; i < generations; i++){
        execute();
    }
}

template<typename T, typename L>
std::vector<T> Population<T, L>::get_bests(){
    std::vector<T> bests;
    std::vector<L> fitnesses;
    for(auto gene : genes){
        fitnesses.emplace_back(evaluate(gene));
    }
    if(rank != nullptr){
        std::vector<int> ranks = rank(fitnesses);
        for(int i = 0; i < genes.size(); i++){
            if(ranks[i] == 1){
                bests.insert(genes[i]);
            }
        }
        return bests;
    } 
    auto max_it = std::max_element(fitnesses.begin(), fitnesses.end());
    for(int i = 0; i < genes.size(); i++){
        if(fitnesses[i] == *max_it){
            bests.insert(genes[i]);
        }
    }
    return bests;
}

template<typename T, typename L>
std::vector<T> Population<T, L>::get_genes(){
    return genes;
}

template<typename T, typename L>
std::string Population<T, L>::to_string(){
    std::string s;
    for (auto gene : genes) {
        s += std::to_string(gene) + "\n";
    }
    return s;
}